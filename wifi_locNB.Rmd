---
title: "Wi-Fi Positioning"
output: 
  html_notebook:
    highlight: pygments
    theme: cerulean
    toc: yes
    toc_float: yes
    toc_depth: 4
    
---


```{r setup, include=FALSE }
knitr::opts_chunk$set(echo = TRUE, tidy=TRUE)
options(knitr.table.format='html')
```
##Introduction
Unlike outdoor positioning which uses GPS satellites, indoor locationing with a cell phone is a challenge due to poor or no acccess to satellite signals.  An active area of research to address this problem revolves around the use of signals from Wireless Access Points (WAP's) in a building.  The approach covered in this project known as fingerprinting uses a training set of particular positions in a building and the corresponding signal strength from any and all WAP's in the vicinity.  In this way, a 'fingerprint' of WAP signal strength is produced for each position in a building.  One challenge to this approach is that the received signal strength can vary based on the phone brand and model, and the position of the phone (i.e. the height of phone owner).

This project will investigate classification models to predict the location (building, floor, and location ID) on the multi-building of Jaume I University.  The data set is publicly available at the [UCI  Machine Learning repository](http://archive.ics.uci.edu/ml/datasets/UJIIndoorLoc).

##1. Frame the Problem
The data set contains over 933 reference points or distinct positions within the buildings.  In addition to the received signal strength of the 520 possible WAP's, a fingerprint for a location contains the building, floor, SpaceID, relative position to the SpaceID, and the latitude/longitude coordinates.  The SpaceID is essentially a room within a building while the relative position to the SpaceID is a location either inside the room or at the entrance in the hallway.  It was initially decided to use only the the positions outside of a spaces as part of a location ID. To frame this as a classification problem, a unique location ID needs to be created for each reference point.  

##2. Collect the Data 
First we'll load the packages that will be used in this analysis.

```{r  message=FALSE, warning=FALSE}
library(caret)      #R modeling workhorse & ggplot2
library(tidyverse)  #Package for tidying datalibrary(magrittr)   #Enables piping
#library(Hmisc)      #for descriptive statistics
library(parallel)
library(doParallel)
library(kknn)       #Weighted k-NN
library(kernlab)    #For SVMLinear method
library(rgl)        #for 3D plotting
library(scatterplot3d)
library(scales)
library(ranger)     #Random forest
library(C50)        #C5.0 decision tree with boosting
library(e1071)      #Randome forest
#library(doMC)
library(broom)
library(kableExtra)

```
###2.1 Load Data Set
The data is loaded into our working environment using the read_csv() function from the readr package.  This results in the data being stored as a tibble which is a data frame with some performance enhancements.

```{r  message=FALSE, results='hide', warning=FALSE}
##-- Training Data
wifi_data <- read_csv('trainingData.csv', na='100')
dim(wifi_data)
```
The dim() function tells us the dimensions of the data set which has 19937 instances or rows and 529 features or columns.  


###2.2 Inspect Data
We'll use the glimpse() funtion to get a quick look at the data.  The output is a transposed version of the data with the columns shown as rows so it's possible to see all of the features if needed.  In this case, we know the first 520 columns are the individual wireless access points (WAP's) so the data has been sliced to just show the last 20 features of the data set.

```{r}
glimpse(wifi_data[,510:529])
```
We can see that all of the reference point location information is found in the last 9 features.  We can also see that there are several things that need to be addressed when we process the data.  For instance, the second column above shows the data type for each feature.  Several of them are strings (<chr>) when they should be numeric.  There are going to be many missing values for the WAP readings which makes sense as only a small subset of the WAPs will be detected for each location.  However, we'll need a strategy for how to deal with these missing values prior to building our predictive models.

####**Attribute Defitions**
```{r message=FALSE}
wifi_defTable <- read.csv('Wifi_Attribute_Definitions.csv')
knitr::kable(wifi_defTable) %>% 
  kable_styling(bootstrap_options = c('striped', 'hover', 'responsive', 'bordered'), full_width = F, font_size = 14)
```

##3. Process the Data
The first thing we'll do is convert all of our features to numeric data types.  This results in a matrix which we'll then convert back into a tibble.

```{r}
#-convert features to numeric
wifi_trainData <- sapply(wifi_data, as.numeric)
wifi_trainData <- as_tibble(wifi_trainData)
```

The floor numbers are in the range of 0-4 in the data set so we'll recode them so floor 1 is the ground floor rather than 0.
```{r}
#recode floor factor level names
wifi_trainData$FLOOR <- recode(wifi_trainData$FLOOR, '0'=1, '1'=2, '2'=3, '3'=4, '4'=5)

```

Next, we'll convert several of the categorical variables or features using the factor() function.
```{r}
#convert categoricals to factor
wifi_trainData$BUILDINGID <- factor(wifi_trainData$BUILDINGID)
wifi_trainData$SPACEID <- factor(wifi_trainData$SPACEID)
wifi_trainData$RELATIVEPOSITION <- factor(wifi_trainData$RELATIVEPOSITION)
wifi_trainData$FLOOR <- factor(wifi_trainData$FLOOR)
```

It's likely that the number of WAPs detected by a phone at a location would be positively correlated with location classification accuracy.  To be able to explore that idea, a column is added that contains the sum of WAPs detected.   

```{r}
#add count of WAP's detected
wifi_trainData$WAP_num <- apply(wifi_trainData[,1:520], 1, function(x) length(which(!is.na(x))))
```

Next, we'll filter the data set such that it only contains locations outside of spaces (i.e corridor).

```{r}
#-Filter on hallway positions
wifi_trainData <- filter(wifi_trainData, wifi_trainData$RELATIVEPOSITION==2)
```

To define a unique location ID for each location entrance in the 3 buildings, we'll use the group_indices() function of dplyr.  This will be our dependent variable for our classification models so we need to convert it to a categorical variable using the factor() function.

```{r}
#consolidate position identifiers
wifi_trainData$ID <- wifi_trainData %>% 
  group_indices(BUILDINGID, FLOOR, SPACEID)

#convert ID variable to factor
wifi_trainData$ID <- factor(wifi_trainData$ID)
```
To determine how many different classess we have for classification, we can use the nlevels() function on the ID variable.

```{r}
#count of ID classes for classification
nlevels(wifi_trainData$ID)
```

Next we'll remove any variables that contain only NA values.
```{r message=FALSE}
#remove columns with all NA values
wifi_trainData <- wifi_trainData[,colSums(is.na(wifi_trainData[1:16608,]))<nrow(wifi_trainData[1:16608,])]

#glimpse(wifi_trainData)  #removes 76 columns

```
This results in the removal of 76 columns.  We'll do the same for rows that contain no signal received from any of the 520 WAPs.

```{r}
#remove rows with all NA values
wifi_trainData <- wifi_trainData[rowSums(is.na(wifi_trainData[,1:444])) != ncol(wifi_trainData[,1:444]),]
#removes 858 rows
```

Finally, we will address the many missing values in the data set which are currently a placeholder for the absence of a signal from a WAP. The values for the signal range from -104 to 0 dBm with 0 being the strongest signal and -104 being the weakest.  The value of -110 dBm was chosen to represent no signal as it is beyond the weakest signal in the database. 

```{r}
#convert NA's to -110
wifi_trainData[is.na(wifi_trainData)] <- -110
```

```{r}
#Subset by building 2
wifi_B2 <- filter(wifi_trainData, BUILDINGID==2)

wifi_B2mod <- select(wifi_B2,-RELATIVEPOSITION, -USERID,
                     -TIMESTAMP, -LONGITUDE, -LATITUDE, -BUILDINGID, -SPACEID)

nlevels(wifi_B2mod$ID) #731 levels

```
```{r}
#remove empty factor levels
wifi_B2mod$ID <- factor(wifi_B2mod$ID)
nlevels(wifi_B2mod$ID) #313 levels
hist(table(wifi_B2mod$ID))
```

##4. Explore the Data

```{r}
#3D plot of data- all buildings & flooors
scatterplot3d(wifi_trainData$LONGITUDE, wifi_trainData$LATITUDE, wifi_trainData$FLOOR,
              type='p',
              highlight.3d = FALSE,
              color='blue',
              angle=155,
              pch=16,
              box=FALSE,
              main = "Location Reference Points Across Three Buildings \nof UJIIndoorLoc Data Set",
              sub='Before Preprocessing',
              cex.lab = 1,
              cex.main=1,
              cex.sub=1,
              col.sub='blue',
              xlab='Longitude', ylab='Latitude',zlab = 'Building Floor')

```
```{r}
hist(table(wifi_trainData$ID))
```


```{r}
#Distribution of WAP count by building and floor
ggplot(wifi_trainData, aes(x=WAP_num, fill=FLOOR)) + geom_bar() +
  facet_grid(BUILDINGID~.) +
  theme(text = element_text(size=20)) +
  ggtitle('Distribution of Detected Wireless Access Points by Building')+
  labs(x="Number of WAP's Detected by Building", y= 'Counts by Building Floor' ) +
  theme(panel.border=element_rect(colour='black', fill=NA))
```


##5.  Build Predictive Models {.tabset .tabset-pills}

```{r}
wifi_train <- select(wifi_trainData, -RELATIVEPOSITION, -USERID, -WAP_num, -PHONEID,
                     -TIMESTAMP, -LONGITUDE, -LATITUDE, -BUILDINGID, -SPACEID, -FLOOR)
```


```{r}
fitControl <- trainControl(method = "repeatedcv", number = 10, repeats=3, allowParallel = TRUE)

```
###5.1 kNN

```{r eval=FALSE}
registerDoMC(cores=16)  #for AWS EC2 use
#cluster <- makeCluster(detectCores() - 1)
#registerDoParallel(cluster)



set.seed(7811)

knn_grid <- expand.grid(.k=c(1:5))

knn_fit <- train(ID~., data=wifi_train, 
                        method='knn',
                        preProcess = c('zv'),
                        tuneGrid=knn_grid,
                        tuneLength=10,
                        trControl = fitControl)

#stopCluster(cluster)
#registerDoSEQ()
```

```{r}
knn_fit$results
```
### 5.2 Decision Tree
```{r eval=FALSE}
registerDoMC(cores=16)

set.seed(7811)
dtree_fit <- train(ID~., wifi_train,
                          method='C5.0', 
                          preProcess = c('zv'),
                          trControl = fitControl)
```

```{r}
dtree_fit$results
```
### 5.3 Random Forest
```{r eval=FALSE}
registerDoMC(cores=16)

set.seed(7811)

rf_fit <- train(ID~., wifi_train,
                       method='ranger', 
                       preProcess = c('zv'),
                       trControl = fitControl)
```

```{r}
rf_fit$results
```




##5.4  Summary of Results

```{r}
results <- resamples(list(kNN=knn_fit, RF=rf_fit, C5.0=dtree_fit))

summary(results)
bwplot(results)
dotplot(results)
```

```{r}
#Select instances that were correctly and incorrectly classifed in rf model
rf_hit <- wifi_trainData[which(rf_fit$finalModel$predictions==wifi_trainData$ID),]
rf_mis <- wifi_trainData[which(rf_fit$finalModel$predictions != wifi_trainData$ID),]

hist(table(rf_hit$ID))
hist(table(rf_mis$ID))
```
```{r}
s3d <- scatterplot3d(rf_hit$LONGITUDE, rf_hit$LATITUDE, rf_hit$FLOOR,
                     type='p',
                     highlight.3d = FALSE,
                     color='blue',
                     angle=165,
                     pch=5,
                     box=FALSE,
                     zlim=c(1,5),
                     main = 'Correctly and Incorrectly Classified Locations in Building 2 Test Set',
                     sub='Random Forest Model',
                     xlab='Longitude', ylab='Latitude',zlab = 'Building 2 Floor',
                     cex.lab = 1.5,
                     cex.main=1.5,
                     cex.sub=1.5,
                     col.sub='blue')
#s3d$points(rf_mis$LONGITUDE, rf_mis$LATITUDE, #rf_mis$FLOOR,col='red', pch=16)
```

```{r}
ggplot(rf_hit, aes(x=factor(PHONEID))) + geom_bar(fill='blue') +
  ggtitle('Count of Correctly Classified by Phone ID')
phone_hit <- tidy(table(rf_hit$PHONEID))
names(phone_hit) <- c('PhoneID', 'Count_hit')
```


```{r}
ggplot(rf_mis, aes(x=factor(PHONEID))) + geom_bar(fill='blue') +
  ggtitle('Count of Misclassified by Phone ID')
phone_mis <- tidy(table(rf_mis$PHONEID))
names(phone_mis) <- c('PhoneID', 'Count_miss')

```
```{r}
x <- merge(x=phone_hit, y=phone_mis, by = 'PhoneID')
y <- mutate(x, Percent_miss = round(Count_miss/(Count_miss + Count_hit)*100,3))
```
```{r}
ggplot(y, aes(x=factor(PhoneID), y= Percent_miss)) +
  geom_bar(stat='identity', fill='blue', colour='black') + 
  ggtitle('Percent of Incorrectly Classified Instances by PhoneID')
```
```{r}
phone_wap <- filter(rf_mis, PHONEID==17)


```

```{r}
hist(phone_wap$WAP_num)
table(phone_wap$WAP_num)
```
```{r}
s3d <- scatterplot3d(phone_wap$LONGITUDE, phone_wap$LATITUDE, phone_wap$FLOOR,
                     type='p',
                     highlight.3d = FALSE,
                     color='blue',
                     angle=130,
                     pch=5,
                     box=FALSE,
                     zlim=c(1,5),
                     main = 'Correctly and Incorrectly Classified Locations in Building 2 Test Set',
                     sub='Random Forest Model',
                     xlab='Longitude', ylab='Latitude',zlab = 'Building 2 Floor',
                     cex.lab = 1.5,
                     cex.main=1.5,
                     cex.sub=1.5,
                     col.sub='blue')
```

```{r}
wifi_trainData_Tsf <- filter(wifi_trainData, PHONEID != 17)
```

